# -*- coding: utf-8 -*-
"""Edge Histogram Descriptor.ipynb

Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/13Bf8oN3tkXL-3jaqFfNjx3WsHjD6Zogt

Implementación basada en https://github.com/scferrada/imgpedia/blob/master/IMGdescriptors/Python/EdgeHistogramComputer.py

Más información en https://www.youtube.com/watch?v=jzbnvrvjpWI
"""

# Librerias
import sys
import cv2
from datetime import datetime
import csv
import numpy as np
import math
from sklearn.svm import SVC
from sklearn.multiclass import OneVsRestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.neural_network import MLPClassifier

# Parametros bash:
# Nombre de la base de datos en el cluster
base_datos_param = sys.argv[1]
# Clasificador
CLASSIFIER = sys.argv[2]

def edge_histogram_descriptor(frame):
  
  # Raiz cuadrada de dos:
  sqrt2 = math.sqrt(2)

  # Filtros para edge detection
  kernels = (np.matrix([[1,1],[-1,-1]]),
            np.matrix([[1,-1],[1,-1]]),
            np.matrix([[sqrt2,0],[0,-sqrt2]]),
            np.matrix([[0,sqrt2],[-sqrt2,0]]),
            np.matrix([[2,-2],[-2,2]]));


  bins = [len(kernels)]
  _range = [0,len(kernels)]

  rows = 4
  cols = 4

  # Convertir a escala de grises (sacado de la implementación de referencia)
  frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

  descriptor = []

  # zeros_like devuelve una matriz de ceros con la misma forma y tipo que una matriz dada 
  # (la misma forma y tipo que frame en este caso)
  # Guardará cuál es el kernel mayor para este 
  dominantGradients = np.zeros_like(frame)

  # Aplicación del primer filtro para edge detection (para poder usar la variable maxGradient posteriormente)
  maxGradient = cv2.filter2D(frame, cv2.CV_32F, kernels[0])
  # calcula el abs de todos los elementos de maxGradient
  maxGradient = np.absolute(maxGradient)

  threshold = None
  #threshold = 50
  
  for k in range(1, len(kernels)):
    kernel = kernels[k]
    # Aplicación de otros filtros para edge detection
    gradient = cv2.filter2D(frame, cv2.CV_32F, kernel)
    gradient = np.absolute(gradient)
    # Si el máximo de estas edge strenghts excede un cierto umbral preestablecido,
    # entonces el bloque de imagen correspondiente se considera un bloque de borde
    # se guarda el resultado en maxGradient (tercer parámetro)
    np.maximum(maxGradient, gradient, maxGradient)
    indices = (maxGradient == gradient)
    if threshold != None:
      for i in range(len(maxGradient)):
        for j in range(len(maxGradient[i])):
          if maxGradient[i][j] < threshold:
            maxGradient[i][j] = -1
    dominantGradients[indices] = k

  #print('dominantGradients:\n', dominantGradients)
    
  # height y width de la imagen
  frameH, frameW = frame.shape
  
  for row in range(rows):
    for col in range(cols):
      # Recorrer rows x cols
      mask = np.zeros_like(frame)
      # "Resize" de las imágenes (dentro del mask) para poder tomar uno de los bloques de la división de 4x4
      a = int((frameH/rows)*row)
      b = int((frameH/rows)*(row+1))
      c = int((frameW/cols)*col)
      d = int(((frameW/cols)*(col+1)))
      # filas x columnas
      mask[a:b,c:d] = 255
      #print('mask\n', mask)
      hist = cv2.calcHist([dominantGradients], [0], mask, bins, _range)
      hist = cv2.normalize(hist, None)
      descriptor.append(hist)
  
  return np.concatenate(np.concatenate([x for x in descriptor]))

def read_images(txt): # txt: archivo.txt
  labels = np.array([])

  # Lectura de nombres de archivos de entrenamiento
  path_base = PATH_BASE
  f = open(path_base + "000/" + txt,"r")
  lineas = f.readlines()

  imagenes = []
  for i in range(1, len(lineas)):
    nombreArchivo = lineas[i].split()[0]
    labels = np.append(labels, lineas[i].split()[1])
    path = path_base + "images/" + nombreArchivo
    img = cv2.imread(path)
    imagenes.append(img)
  return imagenes, labels # retorna un array de imágenes y un array de nombre de clases

PATH_BASE = "../databases/" + base_datos_param + "/"
# Lectura imagenes entrenamiento
imagenes_entrenamiento, labels_entrenamiento =  read_images("train.txt")
# Lectura de imágnes de prueba
imagenes_prueba, labels_prueba =  read_images("test.txt")

# TRAINING
histogramas_entrenamiento = []
for imagen in imagenes_entrenamiento:
  resultado = edge_histogram_descriptor(imagen)
  histogramas_entrenamiento.append(resultado)

# verificación 
print(histogramas_entrenamiento[0])
print(len(histogramas_entrenamiento))

print("Entrenando clasificador...")
if CLASSIFIER == 'ovsr':
  svm = OneVsRestClassifier(SVC(kernel = 'linear'))
  svm.fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = svm
elif CLASSIFIER == 'svc':
  svm = SVC(kernel = 'linear')
  svm.fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = svm
elif CLASSIFIER == 'knn':
  n_neighbors = 1
  knn = KNeighborsClassifier(n_neighbors)
  knn.fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = knn
elif CLASSIFIER == 'rfc':
  rfc = RandomForestClassifier(random_state=0)
  rfc.fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = rfc
elif CLASSIFIER == 'mlp':
  clf = MLPClassifier(random_state=0).fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = clf

# PRUEBA
histogramas_prueba = []
for imagen in imagenes_prueba:
  resultado = edge_histogram_descriptor(imagen)
  histogramas_prueba.append(resultado)

# verificación 
print(histogramas_prueba[0])
print(len(histogramas_prueba))

#SVC
predicciones = _classifier.predict(histogramas_prueba)
predicciones

# Exactitud
from sklearn.metrics import accuracy_score
print ('Exactitud:', accuracy_score(labels_prueba, predicciones))

print("Guardar resultados en archivos...")
now = datetime.now()
FECHA_HORA = str(now.year) + '-' + str(now.month) + '-' + str(now.day) + '-' + str(now.hour)  + str(now.minute) + str(now.second)
CSV_PATH = "../resultados/EDGE_HISTOGRAM_DESCRIPTOR_" + base_datos_param + '_' + FECHA_HORA +  "_" + CLASSIFIER + ".csv"

titulos = ["Exactitud"] # Para imprimir en csv
with open(CSV_PATH,'w') as f:
  w = csv.writer(f)
  w.writerow(titulos)
  w.writerow([accuracy_score(labels_prueba, predicciones)])


# guardar vectores de caracteristicas
TRAIN_PATH = "../resultados/EDGE_HISTOGRAM_DESCRIPTOR_train_" + base_datos_param + '_' + FECHA_HORA +  "_" + CLASSIFIER + ".csv"
TEST_PATH = "../resultados/EDGE_HISTOGRAM_DESCRIPTOR_test_" + base_datos_param + '_' + FECHA_HORA +  "_" + CLASSIFIER + ".csv"

with open(TRAIN_PATH,'w+') as f:
  w = csv.writer(f)
  titulos = ["CLASE"] + list(range(len(histogramas_entrenamiento[0])))
  w.writerow(titulos)
  for i in range(len(histogramas_entrenamiento)):
    fila = []
    fila.append(labels_entrenamiento[i])
    fila = fila + list(histogramas_entrenamiento[i])
    w.writerow(fila)

with open(TEST_PATH,'w+') as f:
  w = csv.writer(f)
  titulos = ["CLASE"] + list(range(len(histogramas_prueba[0])))
  w.writerow(titulos)
  for i in range(len(histogramas_prueba)):
    fila = []
    fila.append(labels_prueba[i])
    fila = fila + list(histogramas_prueba[i])
    w.writerow(fila)

print("Terminado!!")

