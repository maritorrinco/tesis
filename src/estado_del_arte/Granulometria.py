# -*- coding: utf-8 -*-
"""Granulometría prueba.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TTViokjkI4fzHnOVPaV4nCwaxZmiRQTz
"""

import sys
import cv2
import numpy as np 
import statistics as stats
from sklearn.svm import SVC
from sklearn.multiclass import OneVsRestClassifier
from sklearn.neighbors import KNeighborsClassifier
from datetime import datetime
import csv
from scipy.sparse import csr_matrix
import scipy.sparse
from sklearn.svm import LinearSVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.neural_network import MLPClassifier

# Pruebas a realizar en el cluster para todas las bases de datos:
# Volumen y Energia, ambos MARGINAL PROCESSING --> ya que fueron los que obtienen mejores resultados en Outex13
# Las pruebas con lambda desde 0 hasta 15

# Parametros bash:
# V-> Volumen; E -> Energia
medida_param = sys.argv[1]
# Nombre de la base de datos en el cluster
base_datos_param = sys.argv[2]
# Escala de grises o RGB
en_escala_grises = False
canales_param = sys.argv[3]
if canales_param == 'EG':
  en_escala_grises = True
# Clasificador
CLASSIFIER = sys.argv[4]
print("Clasificador parametro:", CLASSIFIER)

"""
# Funciones
## Lectura de imágenes
"""

def read_images(txt): # txt: archivo.txt
  labels = np.array([])

  # Lectura de nombres de archivos de entrenamiento
  path_base = PATH_BASE
  f = open(path_base + "000/" + txt,"r")
  lineas = f.readlines()

  imagenes = []
  for i in range(1, len(lineas)):
    nombreArchivo = lineas[i].split()[0]
    labels = np.append(labels, lineas[i].split()[1])
    path = path_base + "images/" + nombreArchivo
    img = cv2.imread(path)
    imagenes.append(img)
  return imagenes, labels # retorna un array de imágenes y un array de nombre de clases

"""## Erosión y dilatación (sin cv2)"""

# EROSIÓN Y DILATACIÓN CLÁSICOS (tardan más que los métodos de cv2, no usar)
def erosion(img, constant, SE):
  #Erosión sin utilizar la función de cv2
  m,n= img.shape # tamaño de la imagen
  imgErode= np.zeros((m,n), dtype=np.uint8)
  for i in range(constant, m-constant):
    for j in range(constant,n-constant):
      temp = img[i-constant:i+constant+1, j-constant:j+constant+1]
      print('temp')
      print(temp)
      product= temp*SE
      imgErode[i,j]= np.min(product)
  
  return imgErode

def dilatacion(img, constant, SE):
  #Dilatacion sin utilizar la función de cv2
  p,q= img.shape # tamaño de la imagen
  imgDilate= np.zeros((p,q), dtype=np.uint8)
  for i in range(constant, p-constant):
    for j in range(constant, q-constant):
      temp= img[i-constant:i+constant+1, j-constant:j+constant+1]
      product= temp*SE
      imgDilate[i,j]= np.max(product)
  
  return imgDilate

# EROSIÓN Y DILATACIÓN Norma Euclídea (para ordenamiento vectorial)
def erosion_norma(img, constant, SE):
  b,g,r = cv2.split(img)
  m,n = b.shape # tamaño de la imagen
  imgErode= np.zeros((m,n), dtype=np.uint8)
  for i in range(constant, m-constant):
    for j in range(constant,n-constant):
      temp_R = r[i-constant:i+constant+1, j-constant:j+constant+1]
      temp_G = g[i-constant:i+constant+1, j-constant:j+constant+1]
      temp_B = b[i-constant:i+constant+1, j-constant:j+constant+1]
      product_R = temp_R * SE
      product_G = temp_G * SE
      product_B = temp_B * SE
      
      listaDeListas = np.array([[ x**2 for x in product_R ], [ x**2 for x in product_G ], [ x**2 for x in product_B ]])
      sumindex = listaDeListas.sum(axis=0)

      imgErode[i,j]= np.min(sumindex)
  
  return imgErode

def dilatacion_norma(img, constant, SE):
  b,g,r = cv2.split(img)
  p,q= b.shape # tamaño de la imagen
  imgDilate= np.zeros((p,q), dtype=np.uint8)
  for i in range(constant, p-constant):
    for j in range(constant, q-constant):
      temp_R = r[i-constant:i+constant+1, j-constant:j+constant+1]
      temp_G = G[i-constant:i+constant+1, j-constant:j+constant+1]
      temp_B = B[i-constant:i+constant+1, j-constant:j+constant+1]
      product_R = temp_R * SE
      product_G = temp_G * SE
      product_B = temp_B * SE

      listaDeListas = np.array([[ x**2 for x in product_R ], [ x**2 for x in product_G ], [ x**2 for x in product_B ]])
      sumindex = listaDeListas.sum(axis=0)
      
      imgDilate[i,j]= np.max(sumindex)
  
  return imgDilate

"""## Medidas (Definición de Volumen, Varianza, Energía)"""

# Medida: Volumen
def volumen(img):
  return np.sum(img)

# Medida: Varianza
def varianza(imagen):
  flat_list = [item for sublist in imagen for item in sublist]
  cardE = len(flat_list)

  media = stats.mean(flat_list)

  varianza = 0
  for p in flat_list:
    varianza = varianza + (int(p) - int(media))**2

  varianza = (1/cardE) * varianza

  return varianza

# Medida: Energía
def energia(img):
  nrg = 0
  width, height = img.shape
  
  for v in range(height):
    for u in range(width):
      nrg += img[u][v]**2
    
  return nrg

"""## Granulometría

### Volumen
"""

# Granulometry ESCALA DE GRISES
def granulometria_EG(image_original, medida):
  image_original_gray = cv2.cvtColor(image_original, cv2.COLOR_BGR2GRAY)
  
  if medida == 'V':
    # Volumen
    medida_img_original = volumen(image_original_gray)
  elif medida == 'E':
    # Energia
    medida_img_original = energia(image_original_gray)

  res_granulometry = []

  #for l in ([0] + list(range(3, 16, 2))):
  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    imagen_opening = cv2.morphologyEx(image_original_gray, cv2.MORPH_OPEN, kernel)
    if medida == 'V':
      # Volumen
      medida_img_opening = volumen(imagen_opening)
    elif medida == 'E':
      # Energia
      medida_img_opening = energia(imagen_opening)
    
    division_volumenes = medida_img_opening / medida_img_original
    res_granulometry.append(division_volumenes)

  return res_granulometry

# Granulometry RGB MARGINAL - Volumen
def granulometria_RGB_MARGINAL(image_original):
  b,g,r = cv2.split(image_original)

  #Volumen:
  volumenorigR = volumen(r)
  volumenorigG = volumen(g)
  volumenorigB = volumen(b)

  res_granulometry = []

  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    imagenR_opening = cv2.morphologyEx(r, cv2.MORPH_OPEN, kernel)
    imagenG_opening = cv2.morphologyEx(g, cv2.MORPH_OPEN, kernel)
    imagenB_opening = cv2.morphologyEx(b, cv2.MORPH_OPEN, kernel)
    volR_opening = volumen(imagenR_opening)
    volG_opening = volumen(imagenG_opening)
    volB_opening = volumen(imagenB_opening)
    division_R = volR_opening / volumenorigR
    division_G = volG_opening / volumenorigG
    division_B = volB_opening / volumenorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

# RGB VECTORIAL Volumen - ORDEN POR UNA COMPONENTE (descomentar el componente que se quiere probar, hecho solo para prueba inicial)
def granulometria_RGB_VECTORIAL(image_original):
  b,g,r = cv2.split(image_original)

  #Volumen:
  #volumenorigR = volumen(r)
  #volumenorigG = volumen(g)
  volumenorigB = volumen(b)

  res_granulometry = []

  for l in ([0] + list(range(3, 16, 2))):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    #imagenR_opening = cv2.morphologyEx(r, cv2.MORPH_OPEN, kernel)
    #imagenG_opening = cv2.morphologyEx(g, cv2.MORPH_OPEN, kernel)
    imagenB_opening = cv2.morphologyEx(b, cv2.MORPH_OPEN, kernel)
    #volR_opening = volumen(imagenR_opening)
    #volG_opening = volumen(imagenG_opening)
    volB_opening = volumen(imagenB_opening)
    #division_R = volR_opening / volumenorigR
    #division_G = volG_opening / volumenorigG
    division_B = volB_opening / volumenorigB
    #res_granulometry.append(division_R)
    #res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

# RGB Vectorial Volumen - Norma Euclídea
def granulometria_RGB_VECTORIAL_norma(image_original):
  b,g,r = cv2.split(image_original)

  #Volumen:
  volumenorigR = volumen(r)
  volumenorigG = volumen(g)
  volumenorigB = volumen(b)

  res_granulometry = []

  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    AeB= erosion_norma(image_original, l, kernel) # Erosión
    #imagen_opening= dilatacion(AeB, l, kernel) # Dilatación
    imagen_opening = cv2.dilate(AeB, kernel) 
    vol_opening = volumen(imagen_opening)
    division_R = vol_opening / volumenorigR
    division_G = vol_opening / volumenorigG
    division_B = vol_opening / volumenorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

"""### Varianza"""

# RGB Marginal - Varianza 
def granulometria_RGB_MARGINAL_varianza(image_original):
  b,g,r = cv2.split(image_original)

  #Varianza:
  varianzaorigR = varianza(r)
  varianzaorigG = varianza(g)
  varianzaorigB = varianza(b)

  res_granulometry = []

  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    imagenR_opening = cv2.morphologyEx(r, cv2.MORPH_OPEN, kernel)
    imagenG_opening = cv2.morphologyEx(g, cv2.MORPH_OPEN, kernel)
    imagenB_opening = cv2.morphologyEx(b, cv2.MORPH_OPEN, kernel)
    varianzaR_opening = varianza(imagenR_opening)
    varianzaG_opening = varianza(imagenG_opening)
    varianzaB_opening = varianza(imagenB_opening)
    division_R = varianzaR_opening / varianzaorigR
    division_G = varianzaG_opening / varianzaorigG
    division_B = varianzaB_opening / varianzaorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

# RGB Vectorial - Varianza (con norma euclídea)
def granulometria_RGB_VECTORIAL_varianza(image_original):
  b,g,r = cv2.split(image_original)

  #Varianza:
  varianzaorigR = varianza(r)
  varianzaorigG = varianza(g)
  varianzaorigB = varianza(b)

  res_granulometry = []

  #for l in ([0] + list(range(3, 16, 2))):
  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    AeB= erosion_norma(image_original, l, kernel) # Erosión
    imagen_opening = cv2.dilate(AeB, kernel) # Dilatación
    varianza_opening = varianza(imagen_opening)
    division_R = varianza_opening / varianzaorigR
    division_G = varianza_opening / varianzaorigG
    division_B = varianza_opening / varianzaorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

"""### Energía"""

# RGB Marginal - Energía 
def granulometria_RGB_MARGINAL_energia(image_original):
  b,g,r = cv2.split(image_original)

  #Energia:
  energiaorigR = energia(r)
  energiaorigG = energia(g)
  energiaorigB = energia(b)

  res_granulometry = []

  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    imagenR_opening = cv2.morphologyEx(r, cv2.MORPH_OPEN, kernel)
    imagenG_opening = cv2.morphologyEx(g, cv2.MORPH_OPEN, kernel)
    imagenB_opening = cv2.morphologyEx(b, cv2.MORPH_OPEN, kernel)
    energiaR_opening = energia(imagenR_opening)
    energiaG_opening = energia(imagenG_opening)
    energiaB_opening = energia(imagenB_opening)
    division_R = energiaR_opening / energiaorigR
    division_G = energiaG_opening / energiaorigG
    division_B = energiaB_opening / energiaorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

# RGB Vectorial - energia (con norma euclídea)
def granulometria_RGB_VECTORIAL_energia(image_original):
  b,g,r = cv2.split(image_original)

  #energia:
  energiaorigR = energia(r)
  energiaorigG = energia(g)
  energiaorigB = energia(b)

  res_granulometry = []

  #for l in ([0] + list(range(3, 16, 2))):
  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    AeB= erosion_norma(image_original, l, kernel) # Erosión
    imagen_opening = cv2.dilate(AeB, kernel) # Dilatación
    energia_opening = energia(imagen_opening)
    division_R = energia_opening / energiaorigR
    division_G = energia_opening / energiaorigG
    division_B = energia_opening / energiaorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

"""### Volumen + Varianza"""

# RGB Marginal - Volumen + Varianza (con norma euclídea)
def granulometria_RGB_MARGINAL_vol_var(image_original):
  b,g,r = cv2.split(image_original)

  #Varianza:
  varianzaorigR = varianza(r)
  varianzaorigG = varianza(g)
  varianzaorigB = varianza(b)
  #Volumen:
  volumenorigR = volumen(r)
  volumenorigG = volumen(g)
  volumenorigB = volumen(b)

  res_granulometry = []

  #for l in ([0] + list(range(3, 16, 2))):
  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    imagenR_opening = cv2.morphologyEx(r, cv2.MORPH_OPEN, kernel)
    imagenG_opening = cv2.morphologyEx(g, cv2.MORPH_OPEN, kernel)
    imagenB_opening = cv2.morphologyEx(b, cv2.MORPH_OPEN, kernel)

    # Volumen
    volR_opening = volumen(imagenR_opening)
    volG_opening = volumen(imagenG_opening)
    volB_opening = volumen(imagenB_opening)
    division_R = volR_opening / volumenorigR
    division_G = volG_opening / volumenorigG
    division_B = volB_opening / volumenorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

    # Varianza
    varianzaR_opening = varianza(imagenR_opening)
    varianzaG_opening = varianza(imagenG_opening)
    varianzaB_opening = varianza(imagenB_opening)
    division_R = varianzaR_opening / varianzaorigR
    division_G = varianzaG_opening / varianzaorigG
    division_B = varianzaB_opening / varianzaorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

# RGB Vectorial - Volumen + Varianza (con norma euclídea)
def granulometria_RGB_VECTORIAL_vol_var(image_original):
  b,g,r = cv2.split(image_original)

  #Varianza:
  varianzaorigR = varianza(r)
  varianzaorigG = varianza(g)
  varianzaorigB = varianza(b)
  #Volumen:
  volumenorigR = volumen(r)
  volumenorigG = volumen(g)
  volumenorigB = volumen(b)

  res_granulometry = []

  #for l in ([0] + list(range(3, 16, 2))):
  for l in range(16):
    n = 2 * l + 1
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT,(n,n))
    AeB= erosion_norma(image_original, l, kernel) # Erosión
    imagen_opening = cv2.dilate(AeB, kernel) # Dilatación
    
    varianza_opening = varianza(imagen_opening)
    division_R = varianza_opening / varianzaorigR
    division_G = varianza_opening / varianzaorigG
    division_B = varianza_opening / varianzaorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

    vol_opening = volumen(imagen_opening)
    division_R = vol_opening / volumenorigR
    division_G = vol_opening / volumenorigG
    division_B = vol_opening / volumenorigB
    res_granulometry.append(division_R)
    res_granulometry.append(division_G)
    res_granulometry.append(division_B)

  return res_granulometry

"""# Ejecución"""

PATH_BASE = "../databases/" + base_datos_param + "/"

# Lectura imagenes entrenamiento
print("Lectura de imágenes de entrenamiento...")
imagenes_entrenamiento, labels_entrenamiento =  read_images("train.txt")

# Lectura de imágnes de prueba
print("Lectura de imágenes de prueba...")
imagenes_prueba, labels_prueba =  read_images("test.txt")

# TRAINING
print("Entrenamiento...")
histogramas_entrenamiento = []
for imagen in imagenes_entrenamiento:
  if en_escala_grises == True:
    resultado = granulometria_EG(imagen, medida_param)
  else:
    if medida_param == 'V':
      resultado = granulometria_RGB_MARGINAL(imagen)
      #resultado = granulometria_RGB_VECTORIAL(imagen)
      #resultado = granulometria_RGB_VECTORIAL_norma(imagen)
      #resultado = granulometria_RGB_VECTORIAL_varianza(imagen)
      #resultado = granulometria_RGB_MARGINAL_varianza(imagen)
      #resultado = granulometria_RGB_VECTORIAL_vol_var(imagen)
    if medida_param == 'E':
      resultado = granulometria_RGB_MARGINAL_energia(imagen)
      #resultado = granulometria_RGB_VECTORIAL_energia(imagen)
      #resultado = granulometria_RGB_MARGINAL_vol_var(imagen)
  
  histogramas_entrenamiento.append(resultado)

#print(histogramas_entrenamiento)
#print(histogramas_entrenamiento)
print(len(histogramas_entrenamiento))

print("Clasificacion...")
print("Dimension de histogramas_entrenamiento: ", len(histogramas_entrenamiento))

#SVC (Entrenamiento del clasificador)
#svm = OneVsRestClassifier(SVC(kernel = 'linear')) # Menor resultado
#svm.fit(histogramas_entrenamiento, labels_entrenamiento)
#svm = SVC(kernel = 'linear')
#svm.fit(histogramas_entrenamiento, labels_entrenamiento)
#n_neighbors = 1
#knn = KNeighborsClassifier(n_neighbors)
#knn.fit(histogramas_entrenamiento, labels_entrenamiento)
#svm = LinearSVC()
#svm.fit(histogramas_entrenamiento, labels_entrenamiento)

print("Entrenando clasificador...")
if CLASSIFIER == 'ovsr':
  svm = OneVsRestClassifier(SVC(kernel = 'linear'))
  svm.fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = svm
elif CLASSIFIER == 'svc':
  svm = SVC(kernel = 'linear')
  svm.fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = svm
elif CLASSIFIER == 'knn':
  n_neighbors = 1
  knn = KNeighborsClassifier(n_neighbors)
  knn.fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = knn
elif CLASSIFIER == 'rfc':
  rfc = RandomForestClassifier(random_state=0)
  rfc.fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = rfc
elif CLASSIFIER == 'mlp':
  max_iter = 1000
  clf = MLPClassifier(random_state=0, max_iter=max_iter).fit(histogramas_entrenamiento, labels_entrenamiento)
  _classifier = clf

# PRUEBA
print("Prueba...")
histogramas_prueba = []
for imagen in imagenes_prueba:
  if en_escala_grises == True:
    resultado = granulometria_EG(imagen, medida_param)
  else:
    if medida_param == 'V':
      resultado = granulometria_RGB_MARGINAL(imagen)
      #resultado = granulometria_RGB_VECTORIAL(imagen)
      #resultado = granulometria_RGB_VECTORIAL_norma(imagen)
      #resultado = granulometria_RGB_VECTORIAL_varianza(imagen)
      #resultado = granulometria_RGB_MARGINAL_varianza(imagen)
      #resultado = granulometria_RGB_VECTORIAL_vol_var(imagen)
    if medida_param == 'E':
      resultado = granulometria_RGB_MARGINAL_energia(imagen)
      #resultado = granulometria_RGB_VECTORIAL_energia(imagen)
      #resultado = granulometria_RGB_MARGINAL_vol_var(imagen)

  histogramas_prueba.append(resultado)

# verificación 
#print(histogramas_prueba)
print(len(histogramas_prueba))

print("Clasificacion...")
print("Dimension de histogramas_prueba: ", len(histogramas_prueba))

#SVC
#predicciones = svm.predict(histogramas_prueba)
#K-nn
#predicciones = knn.predict(histogramas_prueba)

predicciones = _classifier.predict(histogramas_prueba)


# Exactitud
print("Exactitud...")
from sklearn.metrics import accuracy_score
print(accuracy_score(labels_prueba, predicciones))

print("Creacion de archivos con resultados...")
now = datetime.now()
FECHA_HORA = str(now.year) + '-' + str(now.month) + '-' + str(now.day) + '-' + str(now.hour)  + str(now.minute) + str(now.second)
import scipy.sparse
if CLASSIFIER == 'mlp':
  CLASSIFIER = CLASSIFIER + str(max_iter)
CSV_PATH = "../resultados/granulometriaSVM_" + medida_param + "_" + base_datos_param + '_' + FECHA_HORA + '_' + CLASSIFIER + '_' + canales_param + ".csv"

titulos = ["Exactitud"] # Para imprimir en csv
with open(CSV_PATH,'w') as f:
  w = csv.writer(f)
  w.writerow(titulos)
  w.writerow([accuracy_score(labels_prueba, predicciones)])

# guardar vectores de caracteristicas
TRAIN_PATH = "../resultados/granulometriaSVM_" + medida_param + "_" + base_datos_param + "_train_" + FECHA_HORA + '_' + CLASSIFIER + '_' + canales_param + ".csv"
TEST_PATH = "../resultados/granulometriaSVM_" + medida_param + "_" + base_datos_param + "_test_" + FECHA_HORA + '_' + CLASSIFIER + '_' + canales_param + ".csv"

with open(TRAIN_PATH,'w+') as f:
  w = csv.writer(f)
  titulos = ["CLASE"] + list(range(48))
  w.writerow(titulos)
  for i in range(len(histogramas_entrenamiento)):
    fila = []
    fila.append(labels_entrenamiento[i])
    fila = fila + list(histogramas_entrenamiento[i])
    w.writerow(fila)

with open(TEST_PATH,'w+') as f:
  w = csv.writer(f)
  titulos = ["CLASE"] + list(range(48))
  w.writerow(titulos)
  for i in range(len(histogramas_prueba)):
    fila = []
    fila.append(labels_prueba[i])
    fila = fila + list(histogramas_prueba[i])
    w.writerow(fila)

print("Terminado!!")